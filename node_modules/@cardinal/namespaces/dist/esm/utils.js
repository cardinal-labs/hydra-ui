import * as web3 from "@solana/web3.js";
import * as anchor from "@project-serum/anchor";
import { IDL } from "./types/idl";
import { getReverseEntry } from "./accounts";
export const NAMESPACES_PROGRAM_ID = new web3.PublicKey("nameXpT2PwZ2iA6DTNYTotTmiMYusBCYqwBLN2QgF4w");
export const NAMESPACES_IDL = IDL;
export const GLOBAL_RENTAL_PERCENTAGE = 0.2;
export const GLOBAL_CONTEXT_SEED = "context";
export const NAMESPACE_SEED = "namespace";
export const ENTRY_SEED = "entry";
export const REVERSE_ENTRY_SEED = "reverse-entry";
export const CLAIM_REQUEST_SEED = "rent-request";
export function formatName(namespace, name) {
    return namespace === "twitter" ? `@${name}` : `${name}.${namespace}`;
}
export function breakName(fullName) {
    if (fullName.startsWith("@")) {
        return ["twitter", fullName.split("@")[1]];
    }
    const [entryName, namespace] = fullName.split(".");
    return [namespace, entryName];
}
/**
 * shorten the checksummed version of the input address to have 4 characters at start and end
 * @param address
 * @param chars
 * @returns
 */
export function shortenAddress(address, chars = 5) {
    return `${address.substring(0, chars)}...${address.substring(address.length - chars)}`;
}
export function displayAddress(address, shorten = true) {
    return shorten ? shortenAddress(address) : address;
}
export async function tryGetName(connection, pubkey) {
    try {
        const reverseEntry = await getReverseEntry(connection, pubkey);
        return formatName(reverseEntry.parsed.namespaceName, reverseEntry.parsed.entryName);
    }
    catch (e) { }
    return undefined;
}
export async function nameForDisplay(connection, pubkey) {
    const name = tryGetName(connection, pubkey);
    return name || displayAddress(pubkey.toString());
}
export async function claimRequestId(namespaceName, entryName, user) {
    const [namespaceId] = await web3.PublicKey.findProgramAddress([
        anchor.utils.bytes.utf8.encode(NAMESPACE_SEED),
        anchor.utils.bytes.utf8.encode(namespaceName),
    ], NAMESPACES_PROGRAM_ID);
    return web3.PublicKey.findProgramAddress([
        anchor.utils.bytes.utf8.encode(CLAIM_REQUEST_SEED),
        namespaceId.toBytes(),
        anchor.utils.bytes.utf8.encode(entryName),
        user.toBytes(),
    ], NAMESPACES_PROGRAM_ID);
}
export async function nameEntryId(namespaceName, entryName) {
    const [namespaceId] = await web3.PublicKey.findProgramAddress([
        anchor.utils.bytes.utf8.encode(NAMESPACE_SEED),
        anchor.utils.bytes.utf8.encode(namespaceName),
    ], NAMESPACES_PROGRAM_ID);
    return web3.PublicKey.findProgramAddress([
        anchor.utils.bytes.utf8.encode(ENTRY_SEED),
        namespaceId.toBytes(),
        anchor.utils.bytes.utf8.encode(entryName),
    ], NAMESPACES_PROGRAM_ID);
}
export const reverseEntryId = (address) => {
    return web3.PublicKey.findProgramAddress([anchor.utils.bytes.utf8.encode(REVERSE_ENTRY_SEED), address.toBytes()], NAMESPACES_PROGRAM_ID);
};
//# sourceMappingURL=utils.js.map