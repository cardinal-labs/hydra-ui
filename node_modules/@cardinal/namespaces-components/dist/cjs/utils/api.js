"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createClaimRequest = exports.getPendingClaimRequests = exports.approveClaimRequest = exports.setEntryData = exports.claimEntry = exports.initAndClaimEntry = exports.setReverseEntry = exports.revokeAndClaim = exports.tryGetNameEntry = exports.apiBase = void 0;
const tslib_1 = require("tslib");
const namespaces = tslib_1.__importStar(require("@cardinal/namespaces"));
const web3 = tslib_1.__importStar(require("@solana/web3.js"));
const transactions_1 = require("./transactions");
function apiBase(dev) {
    return `https://${dev ? 'dev-api' : 'api'}.cardinal.so`;
}
exports.apiBase = apiBase;
function tryGetNameEntry(connection, namespaceName, entryName) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            const entry = yield namespaces.getNameEntry(connection, namespaceName, entryName);
            return entry;
        }
        catch (e) {
            return null;
        }
    });
}
exports.tryGetNameEntry = tryGetNameEntry;
function revokeAndClaim(cluster, connection, wallet, namespaceName, entryName, duration, reverseEntryId, claimRequestId, certificateMintId, certificateOwnerId) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const entry = yield tryGetNameEntry(connection, namespaceName, entryName);
        const transaction = new web3.Transaction();
        if (!(entry === null || entry === void 0 ? void 0 : entry.parsed.reverseEntry)) {
            yield namespaces.withRevokeReverseEntry(connection, wallet, namespaceName, entryName, reverseEntryId, claimRequestId, transaction);
        }
        yield namespaces.withRevokeEntry(connection, wallet, namespaceName, entryName, certificateMintId, certificateOwnerId, claimRequestId, transaction);
        transaction.feePayer = wallet.publicKey;
        transaction.recentBlockhash = (yield connection.getRecentBlockhash('max')).blockhash;
        yield wallet.signTransaction(transaction);
        const txid = yield web3.sendAndConfirmRawTransaction(connection, transaction.serialize());
        const transaction2 = new web3.Transaction();
        yield namespaces.withClaimEntry(connection, wallet, namespaceName, entryName, certificateMintId, duration || 0, transaction2);
        yield namespaces.withSetReverseEntry(connection, wallet, namespaceName, entryName, certificateMintId, transaction2);
        transaction2.feePayer = wallet.publicKey;
        transaction2.recentBlockhash = (yield connection.getRecentBlockhash('max')).blockhash;
        yield wallet.signTransaction(transaction2);
        return web3.sendAndConfirmRawTransaction(connection, transaction2.serialize());
    });
}
exports.revokeAndClaim = revokeAndClaim;
function setReverseEntry(connection, wallet, namespaceName, entryName, certificateMintId) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const transaction = yield namespaces.withSetReverseEntry(connection, wallet, namespaceName, entryName, certificateMintId, new web3.Transaction());
        transaction.feePayer = wallet.publicKey;
        transaction.recentBlockhash = (yield connection.getRecentBlockhash('max')).blockhash;
        yield wallet.signTransaction(transaction);
        let txid = null;
        txid = yield web3.sendAndConfirmRawTransaction(connection, transaction.serialize());
        return txid;
    });
}
exports.setReverseEntry = setReverseEntry;
function initAndClaimEntry(cluster, connection, wallet, namespaceName, entryName, duration) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const certificateMint = web3.Keypair.generate();
        const transaction = new web3.Transaction();
        yield namespaces.withInitEntry(connection, wallet, certificateMint.publicKey, namespaceName, entryName, transaction);
        yield namespaces.withClaimEntry(connection, wallet, namespaceName, entryName, certificateMint.publicKey, duration || 0, transaction);
        yield namespaces.withSetReverseEntry(connection, wallet, namespaceName, entryName, certificateMint.publicKey, transaction);
        transaction.feePayer = wallet.publicKey;
        transaction.recentBlockhash = (yield connection.getRecentBlockhash('max')).blockhash;
        yield wallet.signTransaction(transaction);
        yield transaction.partialSign(certificateMint);
        return web3.sendAndConfirmRawTransaction(connection, transaction.serialize());
    });
}
exports.initAndClaimEntry = initAndClaimEntry;
function claimEntry(connection, wallet, namespaceName, entryName, certificateMintId, duration) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const transaction = yield namespaces.withClaimEntry(connection, wallet, namespaceName, entryName, certificateMintId, duration || 0, new web3.Transaction());
        yield namespaces.withSetReverseEntry(connection, wallet, namespaceName, entryName, certificateMintId, transaction);
        transaction.feePayer = wallet.publicKey;
        transaction.recentBlockhash = (yield connection.getRecentBlockhash('max')).blockhash;
        yield wallet.signTransaction(transaction);
        let txid = null;
        txid = yield web3.sendAndConfirmRawTransaction(connection, transaction.serialize());
        return txid;
    });
}
exports.claimEntry = claimEntry;
function setEntryData(connection, wallet, namespaceName, entryName, entryData) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const transaction = yield namespaces.withSetEntryData(connection, wallet, namespaceName, entryName, new web3.PublicKey(entryData), new web3.Transaction());
        transaction.feePayer = wallet.publicKey;
        transaction.recentBlockhash = (yield connection.getRecentBlockhash('max')).blockhash;
        yield wallet.signTransaction(transaction);
        let txid = null;
        txid = yield web3.sendAndConfirmRawTransaction(connection, transaction.serialize());
        return txid;
    });
}
exports.setEntryData = setEntryData;
function approveClaimRequest(connection, wallet, namespaceName, claimRequestId) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const transaction = yield namespaces.withUpdateClaimRequest(connection, wallet, namespaceName, claimRequestId, true, new web3.Transaction());
        transaction.feePayer = wallet.publicKey;
        transaction.recentBlockhash = (yield connection.getRecentBlockhash('max')).blockhash;
        yield wallet.signTransaction(transaction);
        let txid = null;
        txid = yield web3.sendAndConfirmRawTransaction(connection, transaction.serialize());
        return txid;
    });
}
exports.approveClaimRequest = approveClaimRequest;
function getPendingClaimRequests(connection) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        return namespaces.getPendingClaimRequests(connection);
    });
}
exports.getPendingClaimRequests = getPendingClaimRequests;
function createClaimRequest(connection, wallet, namespaceName, entryName) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        return yield (0, transactions_1.signAndSendTransaction)(connection, wallet, yield namespaces.withCreateClaimRequest(connection, wallet, namespaceName, entryName, wallet.publicKey, new web3.Transaction()));
    });
}
exports.createClaimRequest = createClaimRequest;
//# sourceMappingURL=api.js.map