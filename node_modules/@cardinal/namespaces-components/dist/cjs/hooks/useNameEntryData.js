"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useNameEntryData = exports.getNameEntryData = void 0;
const tslib_1 = require("tslib");
const certificates_1 = require("@cardinal/certificates");
const namespaces_1 = require("@cardinal/namespaces");
const metaplex = tslib_1.__importStar(require("@metaplex/js"));
const anchor = tslib_1.__importStar(require("@project-serum/anchor"));
const splToken = tslib_1.__importStar(require("@solana/spl-token"));
const web3_js_1 = require("@solana/web3.js");
const react_1 = require("react");
function getNameEntryData(connection, namespaceName, entryName) {
    var _a, _b;
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const nameEntry = yield (0, namespaces_1.getNameEntry)(connection, namespaceName, entryName);
        const { mint } = nameEntry.parsed;
        const [[metaplexId], [certificateId]] = yield Promise.all([
            web3_js_1.PublicKey.findProgramAddress([
                anchor.utils.bytes.utf8.encode(metaplex.programs.metadata.MetadataProgram.PREFIX),
                metaplex.programs.metadata.MetadataProgram.PUBKEY.toBuffer(),
                mint.toBuffer(),
            ], metaplex.programs.metadata.MetadataProgram.PUBKEY),
            (0, certificates_1.certificateIdForMint)(mint),
        ]);
        const [metaplexData, certificate] = yield Promise.all([
            metaplex.programs.metadata.Metadata.load(connection, metaplexId),
            (0, certificates_1.getCertificate)(connection, certificateId),
        ]);
        let json;
        try {
            json =
                metaplexData.data.data.uri &&
                    (yield fetch(metaplexData.data.data.uri).then((r) => r.json()));
        }
        catch (e) {
            console.log("Failed to get json", json);
        }
        const largestHolders = yield connection.getTokenLargestAccounts(mint);
        const certificateMintToken = new splToken.Token(connection, mint, splToken.TOKEN_PROGRAM_ID, 
        // not used
        anchor.web3.Keypair.generate());
        const largestTokenAccount = ((_a = largestHolders === null || largestHolders === void 0 ? void 0 : largestHolders.value[0]) === null || _a === void 0 ? void 0 : _a.address) &&
            (yield certificateMintToken.getAccountInfo((_b = largestHolders === null || largestHolders === void 0 ? void 0 : largestHolders.value[0]) === null || _b === void 0 ? void 0 : _b.address));
        let isOwnerPDA = false;
        if (largestTokenAccount === null || largestTokenAccount === void 0 ? void 0 : largestTokenAccount.owner) {
            const ownerAccountInfo = yield connection.getAccountInfo(largestTokenAccount === null || largestTokenAccount === void 0 ? void 0 : largestTokenAccount.owner);
            isOwnerPDA =
                (ownerAccountInfo === null || ownerAccountInfo === void 0 ? void 0 : ownerAccountInfo.owner.toString()) === namespaces_1.NAMESPACES_PROGRAM_ID.toString();
        }
        return {
            nameEntry,
            certificate,
            metaplexData,
            arweaveData: { pubkey: metaplexId, parsed: json },
            largestHolders: largestHolders.value,
            owner: largestTokenAccount === null || largestTokenAccount === void 0 ? void 0 : largestTokenAccount.owner,
            isOwnerPDA,
        };
    });
}
exports.getNameEntryData = getNameEntryData;
const useNameEntryData = (connection, namespaceName, entryName) => {
    const [loadingNameEntry, setLoadingNameEntry] = (0, react_1.useState)(undefined);
    const [nameEntryData, setNameEntryData] = (0, react_1.useState)(undefined);
    const refreshNameEntryData = () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
        if (!entryName || !connection)
            return;
        setLoadingNameEntry(true);
        try {
            const data = yield getNameEntryData(connection, namespaceName, entryName);
            setNameEntryData(data);
        }
        catch (e) {
            setNameEntryData(undefined);
            console.log("Failed to get name entry: ", e);
        }
        finally {
            setLoadingNameEntry(false);
        }
    });
    (0, react_1.useMemo)(() => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
        refreshNameEntryData();
    }), [connection, namespaceName, entryName]);
    return {
        nameEntryData,
        refreshNameEntryData,
        loadingNameEntry,
    };
};
exports.useNameEntryData = useNameEntryData;
//# sourceMappingURL=useNameEntryData.js.map