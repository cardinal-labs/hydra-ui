{"version":3,"file":"utils.js","sourceRoot":"","sources":["../../src/utils.ts"],"names":[],"mappings":"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","sourcesContent":["import type { AccountData } from \"@cardinal/common\";\nimport type { web3 } from \"@coral-xyz/anchor\";\nimport { BN } from \"@coral-xyz/anchor\";\nimport type { Wallet } from \"@coral-xyz/anchor/dist/cjs/provider\";\nimport {\n  getAccount,\n  getAssociatedTokenAddressSync,\n  getMint,\n} from \"@solana/spl-token\";\nimport type {\n  ConfirmOptions,\n  Connection,\n  PublicKey,\n  SendTransactionError,\n  Signer,\n  Transaction,\n} from \"@solana/web3.js\";\nimport { sendAndConfirmRawTransaction } from \"@solana/web3.js\";\n\nimport type {\n  GroupRewardCounterData,\n  GroupRewardDistributorData,\n  GroupRewardEntryData,\n} from \"./programs/groupRewardDistributor\";\nimport type {\n  RewardDistributorData,\n  RewardEntryData,\n} from \"./programs/rewardDistributor\";\nimport { getRewardEntries } from \"./programs/rewardDistributor/accounts\";\nimport { findRewardEntryId } from \"./programs/rewardDistributor/pda\";\nimport type { GroupStakeEntryData, StakeEntryData } from \"./programs/stakePool\";\nimport { getStakeEntries } from \"./programs/stakePool/accounts\";\nimport { findStakeEntryIdFromMint } from \"./programs/stakePool/utils\";\n\nexport const executeTransaction = async (\n  connection: Connection,\n  wallet: Wallet,\n  transaction: Transaction,\n  config: {\n    silent?: boolean;\n    signers?: Signer[];\n    confirmOptions?: ConfirmOptions;\n    callback?: (success: boolean) => void;\n  }\n): Promise<string> => {\n  let txid = \"\";\n  try {\n    transaction.feePayer = wallet.publicKey;\n    transaction.recentBlockhash = (\n      await connection.getRecentBlockhash(\"max\")\n    ).blockhash;\n    transaction = await wallet.signTransaction(transaction);\n    if (config.signers && config.signers.length > 0) {\n      transaction.partialSign(...config.signers);\n    }\n    txid = await sendAndConfirmRawTransaction(\n      connection,\n      transaction.serialize(),\n      config.confirmOptions\n    );\n    config.callback && config.callback(true);\n  } catch (e: unknown) {\n    console.log(\"Failed transaction: \", (e as SendTransactionError).logs, e);\n    config.callback && config.callback(false);\n    if (!config.silent) {\n      throw e;\n    }\n  }\n  return txid;\n};\n\n/**\n * Get total supply of mint\n * @param connection\n * @param originalMintId\n * @returns\n */\nexport const getMintSupply = async (\n  connection: web3.Connection,\n  originalMintId: web3.PublicKey\n): Promise<BN> => {\n  return new BN((await getMint(connection, originalMintId)).supply.toString());\n};\n\n/**\n * Get pending rewards of mintIds for a given reward distributor\n * @param connection\n * @param wallet\n * @param mintIds\n * @param rewardDistributor\n * @returns\n */\nexport const getPendingRewardsForPool = async (\n  connection: Connection,\n  wallet: PublicKey,\n  mintIds: PublicKey[],\n  rewardDistributor: AccountData<RewardDistributorData>,\n  UTCNow: number\n): Promise<{\n  rewardMap: {\n    [mintId: string]: { claimableRewards: BN; nextRewardsIn: BN };\n  };\n  claimableRewards: BN;\n}> => {\n  const rewardDistributorTokenAccount = getAssociatedTokenAddressSync(\n    rewardDistributor.parsed.rewardMint,\n    rewardDistributor.pubkey,\n    true\n  );\n  const rewardDistributorTokenAccountInfo = await getAccount(\n    connection,\n    rewardDistributorTokenAccount\n  );\n\n  const stakeEntryIds: PublicKey[] = await Promise.all(\n    mintIds.map(async (mintId) =>\n      findStakeEntryIdFromMint(\n        connection,\n        wallet,\n        rewardDistributor.parsed.stakePool,\n        mintId\n      )\n    )\n  );\n\n  const rewardEntryIds = stakeEntryIds.map((stakeEntryId) =>\n    findRewardEntryId(rewardDistributor.pubkey, stakeEntryId)\n  );\n\n  const [stakeEntries, rewardEntries] = await Promise.all([\n    getStakeEntries(connection, stakeEntryIds),\n    getRewardEntries(connection, rewardEntryIds),\n  ]);\n\n  return getRewardMap(\n    stakeEntries,\n    rewardEntries,\n    rewardDistributor,\n    new BN(rewardDistributorTokenAccountInfo.amount.toString()),\n    UTCNow\n  );\n};\n\n/**\n * Get the map of rewards for stakeEntry to rewards and next reward time\n * Also return the total claimable rewards from this map\n * @param stakeEntries\n * @param rewardEntries\n * @param rewardDistributor\n * @param remainingRewardAmount\n * @returns\n */\nexport const getRewardMap = (\n  stakeEntries: AccountData<StakeEntryData>[],\n  rewardEntries: AccountData<RewardEntryData>[],\n  rewardDistributor: AccountData<RewardDistributorData>,\n  remainingRewardAmount: BN,\n  UTCNow: number\n): {\n  rewardMap: {\n    [stakeEntryId: string]: { claimableRewards: BN; nextRewardsIn: BN };\n  };\n  claimableRewards: BN;\n} => {\n  const rewardMap: {\n    [stakeEntryId: string]: { claimableRewards: BN; nextRewardsIn: BN };\n  } = {};\n\n  for (let i = 0; i < stakeEntries.length; i++) {\n    const stakeEntry = stakeEntries[i]!;\n    const rewardEntry = rewardEntries.find((rewardEntry) =>\n      rewardEntry?.parsed?.stakeEntry.equals(stakeEntry?.pubkey)\n    );\n\n    if (stakeEntry) {\n      const [claimableRewards, nextRewardsIn] = calculatePendingRewards(\n        rewardDistributor,\n        stakeEntry,\n        rewardEntry,\n        remainingRewardAmount,\n        UTCNow\n      );\n      rewardMap[stakeEntry.pubkey.toString()] = {\n        claimableRewards,\n        nextRewardsIn,\n      };\n    }\n  }\n\n  // Compute too many rewards\n  let claimableRewards = Object.values(rewardMap).reduce(\n    (acc, { claimableRewards }) => acc.add(claimableRewards),\n    new BN(0)\n  );\n  if (\n    rewardDistributor.parsed.maxSupply &&\n    rewardDistributor.parsed.rewardsIssued\n      .add(claimableRewards)\n      .gte(rewardDistributor.parsed.maxSupply)\n  ) {\n    claimableRewards = rewardDistributor.parsed.maxSupply.sub(\n      rewardDistributor.parsed.rewardsIssued\n    );\n  }\n\n  if (claimableRewards.gt(remainingRewardAmount)) {\n    claimableRewards = remainingRewardAmount;\n  }\n  return { rewardMap, claimableRewards };\n};\n\n/**\n * Calculate claimable rewards and next reward time for a give mint and reward and stake entry\n * @param rewardDistributor\n * @param stakeEntry\n * @param rewardEntry\n * @param remainingRewardAmount\n * @param UTCNow\n * @returns\n */\nexport const calculatePendingRewards = (\n  rewardDistributor: AccountData<RewardDistributorData>,\n  stakeEntry: AccountData<StakeEntryData>,\n  rewardEntry: AccountData<RewardEntryData> | undefined,\n  remainingRewardAmount: BN,\n  UTCNow: number\n): [BN, BN] => {\n  if (\n    !stakeEntry ||\n    stakeEntry.parsed.pool.toString() !==\n      rewardDistributor.parsed.stakePool.toString()\n  ) {\n    return [new BN(0), new BN(0)];\n  }\n\n  const rewardSecondsReceived =\n    rewardEntry?.parsed.rewardSecondsReceived || new BN(0);\n  const multiplier =\n    rewardEntry?.parsed?.multiplier ||\n    rewardDistributor.parsed.defaultMultiplier;\n\n  let rewardSeconds = (stakeEntry.parsed.cooldownStartSeconds || new BN(UTCNow))\n    .sub(stakeEntry.parsed.lastUpdatedAt ?? stakeEntry.parsed.lastStakedAt)\n    .mul(stakeEntry.parsed.amount)\n    .add(stakeEntry.parsed.totalStakeSeconds);\n  if (rewardDistributor.parsed.maxRewardSecondsReceived) {\n    rewardSeconds = BN.min(\n      rewardSeconds,\n      rewardDistributor.parsed.maxRewardSecondsReceived\n    );\n  }\n  let rewardAmountToReceive = rewardSeconds\n    .sub(rewardSecondsReceived)\n    .div(rewardDistributor.parsed.rewardDurationSeconds)\n    .mul(rewardDistributor.parsed.rewardAmount)\n    .mul(multiplier)\n    .div(new BN(10).pow(new BN(rewardDistributor.parsed.multiplierDecimals)));\n\n  if (\n    rewardDistributor.parsed.maxSupply &&\n    rewardDistributor.parsed.rewardsIssued\n      .add(rewardAmountToReceive)\n      .gte(rewardDistributor.parsed.maxSupply)\n  ) {\n    rewardAmountToReceive = rewardDistributor.parsed.maxSupply.sub(\n      rewardDistributor.parsed.rewardsIssued\n    );\n  }\n\n  if (rewardAmountToReceive.gt(remainingRewardAmount)) {\n    rewardAmountToReceive = remainingRewardAmount;\n  }\n\n  const nextRewardsIn = rewardDistributor.parsed.rewardDurationSeconds.sub(\n    (stakeEntry.parsed.cooldownStartSeconds || new BN(UTCNow))\n      .sub(stakeEntry.parsed.lastUpdatedAt ?? stakeEntry.parsed.lastStakedAt)\n      .add(stakeEntry.parsed.totalStakeSeconds)\n      .mod(rewardDistributor.parsed.rewardDurationSeconds)\n  );\n\n  return [rewardAmountToReceive, nextRewardsIn];\n};\n\n/**\n * Calculate claimable groupRewards and next groupReward time for a give mint and groupReward and stake entry\n * @param groupRewardDistributor\n * @param groupEntry\n * @param groupRewardEntry\n * @param remainingGroupRewardAmount\n * @param UTCNow\n * @returns\n */\nexport const calculatePendingGroupRewards = (\n  groupRewardDistributor: AccountData<GroupRewardDistributorData>,\n  groupEntry: AccountData<GroupStakeEntryData>,\n  groupRewardEntry: AccountData<GroupRewardEntryData> | undefined,\n  groupRewardCounter: AccountData<GroupRewardCounterData> | undefined,\n  remainingGroupRewardAmount: BN,\n  UTCNow: number\n): [BN, BN] => {\n  const rewardSecondsReceived =\n    groupRewardEntry?.parsed.rewardSecondsReceived || new BN(0);\n  const multiplier = groupRewardEntry?.parsed?.multiplier || new BN(1);\n\n  let groupRewardSeconds = (\n    groupEntry.parsed.groupCooldownStartSeconds || new BN(UTCNow)\n  ).sub(groupEntry.parsed.changedAt);\n  if (groupRewardDistributor.parsed.maxRewardSecondsReceived) {\n    groupRewardSeconds = BN.min(\n      groupRewardSeconds,\n      groupRewardDistributor.parsed.maxRewardSecondsReceived\n    );\n  }\n  let groupRewardAmountToReceive = groupRewardSeconds\n    .sub(rewardSecondsReceived)\n    .div(groupRewardDistributor.parsed.rewardDurationSeconds)\n    .mul(groupRewardDistributor.parsed.rewardAmount)\n    .mul(\n      multiplier\n        .mul(groupRewardDistributor.parsed.baseMultiplier)\n        .div(\n          new BN(10).pow(\n            new BN(groupRewardDistributor.parsed.baseMultiplierDecimals)\n          )\n        )\n        .add(\n          groupRewardDistributor.parsed.baseAdder.div(\n            new BN(10).pow(\n              new BN(groupRewardDistributor.parsed.baseAdderDecimals)\n            )\n          )\n        )\n    )\n    .div(\n      new BN(10).pow(new BN(groupRewardDistributor.parsed.multiplierDecimals))\n    );\n\n  if (\n    groupRewardDistributor.parsed.groupCountMultiplier &&\n    groupRewardCounter\n  ) {\n    groupRewardAmountToReceive = groupRewardAmountToReceive\n      .mul(groupRewardCounter.parsed.count)\n      .div(groupRewardDistributor.parsed.groupCountMultiplier)\n      .div(\n        new BN(10).pow(\n          new BN(\n            groupRewardDistributor.parsed.groupCountMultiplierDecimals || 0\n          )\n        )\n      );\n  }\n\n  if (\n    groupRewardDistributor.parsed.maxSupply &&\n    groupRewardDistributor.parsed.rewardsIssued\n      .add(groupRewardAmountToReceive)\n      .gte(groupRewardDistributor.parsed.maxSupply)\n  ) {\n    groupRewardAmountToReceive = groupRewardDistributor.parsed.maxSupply.sub(\n      groupRewardDistributor.parsed.rewardsIssued\n    );\n  }\n\n  if (groupRewardAmountToReceive.gt(remainingGroupRewardAmount)) {\n    groupRewardAmountToReceive = remainingGroupRewardAmount;\n  }\n\n  const nextRewardsIn = groupRewardDistributor.parsed.rewardDurationSeconds.sub(\n    (groupEntry.parsed.groupCooldownStartSeconds || new BN(UTCNow))\n      .sub(groupEntry.parsed.changedAt)\n      .mod(groupRewardDistributor.parsed.rewardDurationSeconds)\n  );\n\n  return [groupRewardAmountToReceive, nextRewardsIn];\n};\n"]}