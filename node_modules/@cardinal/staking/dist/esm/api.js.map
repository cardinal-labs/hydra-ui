{"version":3,"file":"api.js","sourceRoot":"","sources":["../../src/api.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  decodeIdlAccount,\n  fetchAccountDataById,\n  findMintEditionId,\n  findMintMetadataId,\n  findTokenRecordId,\n  getBatchedMultipleAccounts,\n  METADATA_PROGRAM_ID,\n  tryDecodeIdlAccount,\n  tryGetAccount,\n  tryNull,\n} from \"@cardinal/common\";\nimport { tokenManager } from \"@cardinal/token-manager/dist/cjs/programs\";\nimport {\n  CRANK_KEY,\n  getRemainingAccountsForKind,\n  TOKEN_MANAGER_ADDRESS,\n  TokenManagerKind,\n  withRemainingAccountsForInvalidate,\n} from \"@cardinal/token-manager/dist/cjs/programs/tokenManager\";\nimport {\n  findMintCounterId,\n  findTokenManagerAddress,\n} from \"@cardinal/token-manager/dist/cjs/programs/tokenManager/pda\";\nimport { BN } from \"@coral-xyz/anchor\";\nimport type { Wallet } from \"@coral-xyz/anchor/dist/cjs/provider\";\nimport { PROGRAM_ID as TOKEN_AUTH_RULES_ID } from \"@metaplex-foundation/mpl-token-auth-rules\";\nimport {\n  Metadata,\n  TokenDelegateRole,\n  TokenRecord,\n  TokenStandard,\n} from \"@metaplex-foundation/mpl-token-metadata\";\nimport type { Account } from \"@solana/spl-token\";\nimport {\n  ASSOCIATED_TOKEN_PROGRAM_ID,\n  createAssociatedTokenAccountIdempotentInstruction,\n  getAccount,\n  getAssociatedTokenAddressSync,\n  TOKEN_PROGRAM_ID,\n} from \"@solana/spl-token\";\nimport type { Connection, PublicKey, Signer } from \"@solana/web3.js\";\nimport {\n  ComputeBudgetProgram,\n  Keypair,\n  SystemProgram,\n  SYSVAR_INSTRUCTIONS_PUBKEY,\n  SYSVAR_RENT_PUBKEY,\n  Transaction,\n} from \"@solana/web3.js\";\n\nimport type { CardinalRewardDistributor } from \"./idl/cardinal_reward_distributor\";\nimport type { CardinalStakePool } from \"./idl/cardinal_stake_pool\";\nimport type {\n  GroupRewardDistributorKind,\n  GroupRewardDistributorMetadataKind,\n  GroupRewardDistributorPoolKind,\n} from \"./programs/groupRewardDistributor\";\nimport { getGroupRewardEntry } from \"./programs/groupRewardDistributor/accounts\";\nimport { findGroupRewardEntryId } from \"./programs/groupRewardDistributor/pda\";\nimport {\n  withClaimGroupRewards,\n  withCloseGroupRewardEntry,\n  withInitGroupRewardDistributor,\n  withInitGroupRewardEntry,\n  withUpdateGroupRewardDistributor,\n} from \"./programs/groupRewardDistributor/transaction\";\nimport type { RewardDistributorKind } from \"./programs/rewardDistributor\";\nimport {\n  REWARD_DISTRIBUTOR_IDL,\n  REWARD_MANAGER,\n  rewardDistributorProgram,\n} from \"./programs/rewardDistributor\";\nimport {\n  getRewardDistributor,\n  getRewardEntry,\n} from \"./programs/rewardDistributor/accounts\";\nimport {\n  findRewardDistributorId,\n  findRewardEntryId,\n} from \"./programs/rewardDistributor/pda\";\nimport {\n  withInitRewardDistributor,\n  withInitRewardEntry,\n  withUpdateRewardEntry,\n} from \"./programs/rewardDistributor/transaction\";\nimport {\n  ReceiptType,\n  STAKE_POOL_IDL,\n  stakePoolProgram,\n} from \"./programs/stakePool\";\nimport {\n  getStakeEntries,\n  getStakeEntry,\n  getStakePool,\n} from \"./programs/stakePool/accounts\";\nimport { findStakeEntryId } from \"./programs/stakePool/pda\";\nimport {\n  withAddToGroupEntry,\n  withAuthorizeStakeEntry,\n  withInitGroupStakeEntry,\n  withInitStakeEntry,\n  withInitStakeMint,\n  withInitStakePool,\n  withInitUngrouping,\n  withRemoveFromGroupEntry,\n  withUpdateTotalStakeSeconds,\n} from \"./programs/stakePool/transaction\";\nimport {\n  findStakeEntryIdFromMint,\n  remainingAccountsForInitStakeEntry,\n  shouldReturnReceipt,\n} from \"./programs/stakePool/utils\";\n\n/**\n * Convenience call to create a stake pool\n * @param connection - Connection to use\n * @param wallet - Wallet to use\n * @param requiresCollections - (Optional) List of required collections pubkeys\n * @param requiresCreators - (Optional) List of required creators pubkeys\n * @param requiresAuthorization - (Optional) Boolean to require authorization\n * @param overlayText - (Optional) Text to overlay on receipt mint tokens\n * @param imageUri - (Optional) Image URI for stake pool\n * @param resetOnStake - (Optional) Boolean to reset an entry's total stake seconds on unstake\n * @param cooldownSeconds - (Optional) Number of seconds for token to cool down before returned to the staker\n * @param rewardDistributor - (Optional) Parameters to creat reward distributor\n * @returns\n */\nexport const createStakePool = async (\n  connection: Connection,\n  wallet: Wallet,\n  params: {\n    requiresCollections?: PublicKey[];\n    requiresCreators?: PublicKey[];\n    requiresAuthorization?: boolean;\n    overlayText?: string;\n    imageUri?: string;\n    resetOnStake?: boolean;\n    cooldownSeconds?: number;\n    minStakeSeconds?: number;\n    endDate?: BN;\n    doubleOrResetEnabled?: boolean;\n    rewardDistributor?: {\n      rewardMintId: PublicKey;\n      rewardAmount?: BN;\n      rewardDurationSeconds?: BN;\n      rewardDistributorKind?: RewardDistributorKind;\n      maxSupply?: BN;\n      supply?: BN;\n    };\n  }\n): Promise<[Transaction, PublicKey, PublicKey?]> => {\n  const transaction = new Transaction();\n\n  const [, stakePoolId] = await withInitStakePool(\n    transaction,\n    connection,\n    wallet,\n    params\n  );\n  let rewardDistributorId;\n  if (params.rewardDistributor) {\n    [, rewardDistributorId] = await withInitRewardDistributor(\n      transaction,\n      connection,\n      wallet,\n      {\n        stakePoolId: stakePoolId,\n        rewardMintId: params.rewardDistributor.rewardMintId,\n        rewardAmount: params.rewardDistributor.rewardAmount,\n        rewardDurationSeconds: params.rewardDistributor.rewardDurationSeconds,\n        kind: params.rewardDistributor.rewardDistributorKind,\n        maxSupply: params.rewardDistributor.maxSupply,\n        supply: params.rewardDistributor.supply,\n      }\n    );\n  }\n  return [transaction, stakePoolId, rewardDistributorId];\n};\n\n/**\n * Convenience call to create a reward distributor\n * @param connection - Connection to use\n * @param wallet - Wallet to use\n * @param rewardMintId - (Optional) Reward mint id\n * @param rewardAmount - (Optional) Reward amount\n * @param rewardDurationSeconds - (Optional) Reward duration in seconds\n * @param rewardDistributorKind - (Optional) Reward distributor kind Mint or Treasury\n * @param maxSupply - (Optional) Max supply\n * @param supply - (Optional) Supply\n * @returns\n */\nexport const createRewardDistributor = async (\n  connection: Connection,\n  wallet: Wallet,\n  params: {\n    stakePoolId: PublicKey;\n    rewardMintId: PublicKey;\n    rewardAmount?: BN;\n    rewardDurationSeconds?: BN;\n    kind?: RewardDistributorKind;\n    maxSupply?: BN;\n    supply?: BN;\n  }\n): Promise<[Transaction, PublicKey]> =>\n  withInitRewardDistributor(new Transaction(), connection, wallet, params);\n\n/**\n * Convenience call to create a stake entry\n * @param connection - Connection to use\n * @param wallet - Wallet to use\n * @param stakePoolId - Stake pool ID\n * @param originalMintId - Original mint ID\n * @param user - (Optional) User pubkey in case the person paying for the transaction and\n * stake entry owner are different\n * @returns\n */\nexport const createStakeEntry = async (\n  connection: Connection,\n  wallet: Wallet,\n  params: {\n    stakePoolId: PublicKey;\n    originalMintId: PublicKey;\n  }\n): Promise<[Transaction, PublicKey]> => {\n  const stakeEntryId = await findStakeEntryIdFromMint(\n    connection,\n    wallet.publicKey,\n    params.stakePoolId,\n    params.originalMintId\n  );\n  return [\n    await withInitStakeEntry(new Transaction(), connection, wallet, {\n      stakePoolId: params.stakePoolId,\n      stakeEntryId,\n      originalMintId: params.originalMintId,\n    }),\n    stakeEntryId,\n  ];\n};\n\n/**\n * Convenience call to create a stake entry\n * @param connection - Connection to use\n * @param wallet - Wallet to use\n * @param stakePoolId - Stake pool ID\n * @param originalMintId - Original mint ID\n * @returns\n */\nexport const initializeRewardEntry = async (\n  connection: Connection,\n  wallet: Wallet,\n  params: {\n    stakePoolId: PublicKey;\n    originalMintId: PublicKey;\n    multiplier?: BN;\n  }\n): Promise<Transaction> => {\n  const stakeEntryId = await findStakeEntryIdFromMint(\n    connection,\n    wallet.publicKey,\n    params.stakePoolId,\n    params.originalMintId\n  );\n  const stakeEntryData = await tryGetAccount(() =>\n    getStakeEntry(connection, stakeEntryId)\n  );\n\n  const transaction = new Transaction();\n  if (!stakeEntryData) {\n    await withInitStakeEntry(transaction, connection, wallet, {\n      stakePoolId: params.stakePoolId,\n      stakeEntryId,\n      originalMintId: params.originalMintId,\n    });\n  }\n\n  const rewardDistributorId = findRewardDistributorId(params.stakePoolId);\n  await withInitRewardEntry(transaction, connection, wallet, {\n    stakeEntryId: stakeEntryId,\n    rewardDistributorId: rewardDistributorId,\n  });\n\n  await withUpdateRewardEntry(transaction, connection, wallet, {\n    stakePoolId: params.stakePoolId,\n    rewardDistributorId: rewardDistributorId,\n    stakeEntryId: stakeEntryId,\n    multiplier: params.multiplier ?? new BN(1), //TODO default multiplier\n  });\n  return transaction;\n};\n\n/**\n * Convenience call to authorize a stake entry\n * @param connection - Connection to use\n * @param wallet - Wallet to use\n * @param stakePoolId - Stake pool ID\n * @param originalMintId - Original mint ID\n * @returns\n */\nexport const authorizeStakeEntry = (\n  connection: Connection,\n  wallet: Wallet,\n  params: {\n    stakePoolId: PublicKey;\n    originalMintId: PublicKey;\n  }\n) => {\n  return withAuthorizeStakeEntry(new Transaction(), connection, wallet, {\n    stakePoolId: params.stakePoolId,\n    originalMintId: params.originalMintId,\n  });\n};\n\n/**\n * Convenience call to create a stake entry and a stake mint\n * @param connection - Connection to use\n * @param wallet - Wallet to use\n * @param stakePoolId - Stake pool ID\n * @param originalMintId - Original mint ID\n * @param amount - (Optional) Amount of tokens to be staked, defaults to 1\n * @returns\n */\nexport const createStakeEntryAndStakeMint = async (\n  connection: Connection,\n  wallet: Wallet,\n  params: {\n    stakePoolId: PublicKey;\n    originalMintId: PublicKey;\n    receiptName?: string;\n  }\n): Promise<[Transaction, PublicKey, Keypair | undefined]> => {\n  let transaction = new Transaction();\n  const stakeEntryId = await findStakeEntryIdFromMint(\n    connection,\n    wallet.publicKey,\n    params.stakePoolId,\n    params.originalMintId\n  );\n  const stakeEntryData = await tryGetAccount(() =>\n    getStakeEntry(connection, stakeEntryId)\n  );\n  if (!stakeEntryData) {\n    transaction = (\n      await createStakeEntry(connection, wallet, {\n        stakePoolId: params.stakePoolId,\n        originalMintId: params.originalMintId,\n      })\n    )[0];\n  }\n\n  let stakeMintKeypair: Keypair | undefined;\n  if (!stakeEntryData?.parsed.stakeMint) {\n    stakeMintKeypair = Keypair.generate();\n    const stakePool = await getStakePool(connection, params.stakePoolId);\n\n    await withInitStakeMint(transaction, connection, wallet, {\n      stakePoolId: params.stakePoolId,\n      stakeEntryId: stakeEntryId,\n      originalMintId: params.originalMintId,\n      stakeMintKeypair,\n      name:\n        params.receiptName ??\n        `POOl${stakePool.parsed.identifier.toString()} RECEIPT`,\n      symbol: `POOl${stakePool.parsed.identifier.toString()}`,\n    });\n  }\n\n  return [transaction, stakeEntryId, stakeMintKeypair];\n};\n\n/**\n * Convenience method to claim rewards\n * @param connection - Connection to use\n * @param wallet - Wallet to use\n * @param stakePoolId - Stake pool id\n * @param stakeEntryId - Original mint id\n * @returns\n */\nexport const claimRewards = async (\n  connection: Connection,\n  wallet: Wallet,\n  params: {\n    stakePoolId: PublicKey;\n    stakeEntryIds: PublicKey[];\n    lastStaker?: PublicKey;\n    payer?: PublicKey;\n  }\n): Promise<Transaction[]> => {\n  /////// derive ids ///////\n  const rewardDistributorId = findRewardDistributorId(params.stakePoolId);\n  const rewardEntryIds = params.stakeEntryIds.map((stakeEntryId) =>\n    findRewardEntryId(rewardDistributorId, stakeEntryId)\n  );\n\n  /////// get accounts ///////\n  const rewardDistributorData = await tryNull(() =>\n    getRewardDistributor(connection, rewardDistributorId)\n  );\n  if (!rewardDistributorData) throw \"No reward distributor found\";\n  const rewardEntryInfos = await getBatchedMultipleAccounts(\n    connection,\n    rewardEntryIds\n  );\n\n  const rewardMintTokenAccountId = getAssociatedTokenAddressSync(\n    rewardDistributorData.parsed.rewardMint,\n    params.lastStaker ?? wallet.publicKey,\n    true\n  );\n  const txs: Transaction[] = [];\n  for (let i = 0; i < params.stakeEntryIds.length; i++) {\n    const stakeEntryId = params.stakeEntryIds[i]!;\n    const rewardEntryId = rewardEntryIds[i];\n    const tx = new Transaction();\n    /////// update seconds ///////\n    await withUpdateTotalStakeSeconds(tx, connection, wallet, {\n      stakeEntryId,\n      lastStaker: wallet.publicKey,\n    });\n    /////// init ata ///////\n    tx.add(\n      createAssociatedTokenAccountIdempotentInstruction(\n        params.payer ?? wallet.publicKey,\n        rewardMintTokenAccountId,\n        params.lastStaker ?? wallet.publicKey,\n        rewardDistributorData.parsed.rewardMint\n      )\n    );\n    /////// init entry ///////\n    if (!rewardEntryInfos[i]?.data) {\n      const ix = await rewardDistributorProgram(connection, wallet)\n        .methods.initRewardEntry()\n        .accounts({\n          rewardEntry: rewardEntryId,\n          stakeEntry: stakeEntryId,\n          rewardDistributor: rewardDistributorData.pubkey,\n          payer: params.payer ?? wallet.publicKey,\n          systemProgram: SystemProgram.programId,\n        })\n        .instruction();\n      tx.add(ix);\n    }\n    /////// claim rewards ///////\n    const ix = await rewardDistributorProgram(connection, wallet)\n      .methods.claimRewards()\n      .accounts({\n        rewardEntry: rewardEntryId,\n        rewardDistributor: rewardDistributorData.pubkey,\n        stakeEntry: stakeEntryId,\n        stakePool: params.stakePoolId,\n        rewardMint: rewardDistributorData.parsed.rewardMint,\n        userRewardMintTokenAccount: rewardMintTokenAccountId,\n        rewardManager: REWARD_MANAGER,\n        user: params.payer ?? wallet.publicKey,\n        tokenProgram: TOKEN_PROGRAM_ID,\n        systemProgram: SystemProgram.programId,\n      })\n      .remainingAccounts([\n        {\n          pubkey: getAssociatedTokenAddressSync(\n            rewardDistributorData.parsed.rewardMint,\n            rewardDistributorData.pubkey,\n            true\n          ),\n          isSigner: false,\n          isWritable: true,\n        },\n      ])\n      .instruction();\n    tx.add(ix);\n    txs.push(tx);\n  }\n  return txs;\n};\n\nexport const claimRewardsAll = async (\n  connection: Connection,\n  wallet: Wallet,\n  params: {\n    stakePoolId: PublicKey;\n    stakeEntryIds: PublicKey[];\n    lastStaker?: PublicKey;\n    payer?: PublicKey;\n  }\n): Promise<{ tx: Transaction }[][]> => {\n  /////// get accounts ///////\n  const rewardDistributorId = findRewardDistributorId(params.stakePoolId);\n  const rewardDistributorData = await getRewardDistributor(\n    connection,\n    rewardDistributorId\n  );\n  const rewardMintId = rewardDistributorData.parsed.rewardMint;\n  const userRewardTokenAccountId = getAssociatedTokenAddressSync(\n    rewardMintId,\n    wallet.publicKey,\n    true\n  );\n  const rewardTokenAccount = await tryNull(\n    getAccount(connection, userRewardTokenAccountId)\n  );\n  const txs = await claimRewards(connection, wallet, {\n    stakePoolId: params.stakePoolId,\n    stakeEntryIds: params.stakeEntryIds,\n    lastStaker: params.lastStaker,\n    payer: params.payer,\n  });\n  return !rewardTokenAccount\n    ? [\n        txs.slice(0, 1).map((tx) => {\n          tx.instructions = [\n            createAssociatedTokenAccountIdempotentInstruction(\n              wallet.publicKey,\n              userRewardTokenAccountId,\n              wallet.publicKey,\n              rewardMintId\n            ),\n            ...tx.instructions,\n          ];\n          return { tx };\n        }),\n        txs.slice(1).map((tx) => ({ tx })),\n      ]\n    : [txs.map((tx) => ({ tx }))];\n};\n\nexport const stake = async (\n  connection: Connection,\n  wallet: Wallet,\n  params: {\n    stakePoolId: PublicKey;\n    originalMintId: PublicKey;\n    userOriginalMintTokenAccountId: PublicKey;\n    amount?: BN;\n    fungible?: boolean;\n    receiptType?: ReceiptType;\n  }\n): Promise<Transaction> => {\n  const txSeq = await stakeAll(connection, wallet, {\n    stakePoolId: params.stakePoolId,\n    mintInfos: [\n      {\n        mintId: params.originalMintId,\n        tokenAccountId: params.userOriginalMintTokenAccountId,\n        receiptType: params.receiptType,\n        fungible:\n          params.fungible ?? (params.amount && params.amount.gt(new BN(1))),\n        amount: params.amount,\n      },\n    ],\n  });\n  const txs = txSeq[0];\n  if (!txs) throw \"Failed to unstake\";\n  const tx = txs[0];\n  if (!tx) throw \"Failed to unstake\";\n  return tx.tx;\n};\n\n/**\n * Convenience method to stake tokens\n * @param connection - Connection to use\n * @param wallet - Wallet to use\n * @param stakePoolId - Stake pool id\n * @param originalMintId - Original mint id\n * @param userOriginalMintTokenAccountId - User's original mint token account id\n * @param receiptType - (Optional) ReceiptType to be received back. If none provided, none will be claimed\n * @param user - (Optional) User pubkey in case the person paying for the transaction and\n * stake entry owner are different\n * @param amount - (Optional) Amount of tokens to be staked, defaults to 1\n * @returns\n */\nexport const stakeAll = async (\n  connection: Connection,\n  wallet: Wallet,\n  params: {\n    stakePoolId: PublicKey;\n    mintInfos: {\n      mintId: PublicKey;\n      tokenAccountId: PublicKey;\n      fungible?: boolean;\n      amount?: BN;\n      receiptType?: ReceiptType;\n    }[];\n  }\n): Promise<{ tx: Transaction; signers?: Signer[] }[][]> => {\n  /////// derive ids ///////\n  const mintMetadataIds = params.mintInfos.map(({ mintId }) =>\n    findMintMetadataId(mintId)\n  );\n  const mintInfos = params.mintInfos.map(({ mintId, fungible, ...rest }) => ({\n    ...rest,\n    mintId,\n    fungible,\n    stakeEntryId: findStakeEntryId(\n      wallet.publicKey,\n      params.stakePoolId,\n      mintId,\n      fungible ?? false\n    ),\n  }));\n  /////// get accounts ///////\n  const accountData = await fetchAccountDataById(connection, [\n    params.stakePoolId,\n    ...mintInfos.map(({ stakeEntryId }) => stakeEntryId),\n    ...mintMetadataIds,\n  ]);\n\n  /////// preTxs ///////\n  const preTxs: { tx: Transaction; signers: Signer[] }[] = [];\n  const mintInfosWithReceipts = mintInfos.filter(\n    (i) => i.receiptType === ReceiptType.Receipt\n  );\n  const mintReceiptIds: { [s: string]: PublicKey } = {};\n  if (mintInfosWithReceipts.length > 0) {\n    for (let i = 0; i < mintInfosWithReceipts.length; i++) {\n      const { mintId, stakeEntryId } = mintInfosWithReceipts[i]!;\n      const transaction = new Transaction();\n      const stakeEntryInfo = accountData[stakeEntryId.toString()] ?? null;\n      const stakeEntryData = stakeEntryInfo\n        ? tryDecodeIdlAccount<\"stakeEntry\", CardinalStakePool>(\n            stakeEntryInfo,\n            \"stakeEntry\",\n            STAKE_POOL_IDL\n          )\n        : null;\n\n      const stakePoolInfo = accountData[params.stakePoolId.toString()] ?? null;\n      if (!stakePoolInfo) throw \"Stake pool not found\";\n      const stakePoolData = decodeIdlAccount<\"stakePool\", CardinalStakePool>(\n        stakePoolInfo,\n        \"stakePool\",\n        STAKE_POOL_IDL\n      );\n      if (!stakeEntryInfo) {\n        const ix = await stakePoolProgram(connection, wallet)\n          .methods.initEntry(wallet.publicKey)\n          .accountsStrict({\n            stakeEntry: stakeEntryId,\n            stakePool: params.stakePoolId,\n            originalMint: mintId,\n            originalMintMetadata: findMintMetadataId(mintId),\n            payer: wallet.publicKey,\n            systemProgram: SystemProgram.programId,\n          })\n          .remainingAccounts(\n            remainingAccountsForInitStakeEntry(params.stakePoolId, mintId)\n          )\n          .instruction();\n        transaction.add(ix);\n      }\n      let stakeMintKeypair: Keypair | undefined;\n      if (!stakeEntryData?.parsed?.stakeMint) {\n        stakeMintKeypair = Keypair.generate();\n        await withInitStakeMint(transaction, connection, wallet, {\n          stakePoolId: params.stakePoolId,\n          stakeEntryId: stakeEntryId,\n          originalMintId: mintId,\n          stakeMintKeypair,\n          name: `POOl${stakePoolData.parsed.identifier.toString()} RECEIPT`,\n          symbol: `POOl${stakePoolData.parsed.identifier.toString()}`,\n        });\n        if (transaction.instructions.length > 0) {\n          mintReceiptIds[mintId.toString()] = stakeMintKeypair.publicKey;\n          preTxs.push({ tx: transaction, signers: [stakeMintKeypair] });\n        }\n      }\n    }\n  }\n\n  const txs: { tx: Transaction }[] = [];\n  for (let i = 0; i < mintInfos.length; i++) {\n    const {\n      mintId: originalMintId,\n      tokenAccountId: userOriginalMintTokenAccountId,\n      amount,\n      receiptType,\n      stakeEntryId,\n    } = mintInfos[i]!;\n    const mintMetadataId = findMintMetadataId(originalMintId);\n    /////// deserialize accounts ///////\n    const metadataAccountInfo = accountData[mintMetadataId.toString()] ?? null;\n    const mintMetadata = metadataAccountInfo\n      ? Metadata.deserialize(metadataAccountInfo.data)[0]\n      : null;\n    const stakeEntryInfo = accountData[stakeEntryId.toString()] ?? null;\n    const stakeEntryData = stakeEntryInfo\n      ? tryDecodeIdlAccount<\"stakeEntry\", CardinalStakePool>(\n          stakeEntryInfo,\n          \"stakeEntry\",\n          STAKE_POOL_IDL\n        )\n      : null;\n    /////// start transaction ///////\n    const transaction = new Transaction();\n\n    /////// init entry ///////\n    if (!stakeEntryInfo) {\n      const ix = await stakePoolProgram(connection, wallet)\n        .methods.initEntry(wallet.publicKey)\n        .accounts({\n          stakeEntry: stakeEntryId,\n          stakePool: params.stakePoolId,\n          originalMint: originalMintId,\n          originalMintMetadata: mintMetadataId,\n          payer: wallet.publicKey,\n          systemProgram: SystemProgram.programId,\n        })\n        .remainingAccounts(\n          remainingAccountsForInitStakeEntry(params.stakePoolId, originalMintId)\n        )\n        .instruction();\n      transaction.add(ix);\n    }\n\n    if (\n      mintMetadata?.tokenStandard === TokenStandard.ProgrammableNonFungible &&\n      mintMetadata.programmableConfig?.ruleSet\n    ) {\n      transaction.add(\n        ComputeBudgetProgram.setComputeUnitLimit({\n          units: 100000000,\n        })\n      );\n      /////// programmable ///////\n      transaction.add(\n        await stakePoolProgram(connection, wallet)\n          .methods.stakeProgrammable(amount ?? new BN(1))\n          .accountsStrict({\n            stakeEntry: stakeEntryId,\n            stakePool: params.stakePoolId,\n            originalMint: originalMintId,\n            systemProgram: SystemProgram.programId,\n            user: wallet.publicKey,\n            tokenProgram: TOKEN_PROGRAM_ID,\n            tokenMetadataProgram: METADATA_PROGRAM_ID,\n            userOriginalMintTokenAccount: userOriginalMintTokenAccountId,\n            userOriginalMintTokenRecord: findTokenRecordId(\n              originalMintId,\n              userOriginalMintTokenAccountId\n            ),\n            mintMetadata: mintMetadataId,\n            mintEdition: findMintEditionId(originalMintId),\n            authorizationRules: mintMetadata.programmableConfig?.ruleSet,\n            sysvarInstructions: SYSVAR_INSTRUCTIONS_PUBKEY,\n            authorizationRulesProgram: TOKEN_AUTH_RULES_ID,\n          })\n          .instruction()\n      );\n    } else {\n      /////// non-programmable ///////\n      const stakeEntryOriginalMintTokenAccountId =\n        getAssociatedTokenAddressSync(originalMintId, stakeEntryId, true);\n      transaction.add(\n        createAssociatedTokenAccountIdempotentInstruction(\n          wallet.publicKey,\n          stakeEntryOriginalMintTokenAccountId,\n          stakeEntryId,\n          originalMintId\n        )\n      );\n      const ix = await stakePoolProgram(connection, wallet)\n        .methods.stake(amount || new BN(1))\n        .accounts({\n          stakeEntry: stakeEntryId,\n          stakePool: params.stakePoolId,\n          stakeEntryOriginalMintTokenAccount:\n            stakeEntryOriginalMintTokenAccountId,\n          originalMint: originalMintId,\n          user: wallet.publicKey,\n          userOriginalMintTokenAccount: userOriginalMintTokenAccountId,\n          tokenProgram: TOKEN_PROGRAM_ID,\n        })\n        .instruction();\n      transaction.add(ix);\n\n      /////// receipts ///////\n      if (receiptType && receiptType !== ReceiptType.None) {\n        const receiptMintId =\n          receiptType === ReceiptType.Receipt\n            ? mintReceiptIds[originalMintId.toString()] ??\n              stakeEntryData?.parsed?.stakeMint\n            : originalMintId;\n        if (!receiptMintId) {\n          throw \"Stake entry has no receipt mint and you are trying to stake using receipts. Initialize receipt mint first.\";\n        }\n        if (\n          stakeEntryData?.parsed?.stakeMintClaimed ||\n          stakeEntryData?.parsed?.originalMintClaimed\n        ) {\n          throw \"Receipt has already been claimed.\";\n        }\n        if (\n          !stakeEntryData?.parsed ||\n          stakeEntryData.parsed.amount.toNumber() === 0\n        ) {\n          const tokenManagerId = findTokenManagerAddress(receiptMintId);\n          const tokenManagerReceiptMintTokenAccountId =\n            getAssociatedTokenAddressSync(receiptMintId, tokenManagerId, true);\n          transaction.add(\n            createAssociatedTokenAccountIdempotentInstruction(\n              wallet.publicKey,\n              tokenManagerReceiptMintTokenAccountId,\n              tokenManagerId,\n              receiptMintId\n            )\n          );\n          const ix = await stakePoolProgram(connection, wallet)\n            .methods.claimReceiptMint()\n            .accounts({\n              stakeEntry: stakeEntryId,\n              originalMint: originalMintId,\n              receiptMint: receiptMintId,\n              stakeEntryReceiptMintTokenAccount: getAssociatedTokenAddressSync(\n                receiptMintId,\n                stakeEntryId,\n                true\n              ),\n              user: wallet.publicKey,\n              userReceiptMintTokenAccount: getAssociatedTokenAddressSync(\n                receiptMintId,\n                wallet.publicKey,\n                true\n              ),\n              tokenManagerReceiptMintTokenAccount:\n                tokenManagerReceiptMintTokenAccountId,\n              tokenManager: tokenManagerId,\n              mintCounter: findMintCounterId(receiptMintId),\n              tokenProgram: TOKEN_PROGRAM_ID,\n              tokenManagerProgram: TOKEN_MANAGER_ADDRESS,\n              associatedTokenProgram: ASSOCIATED_TOKEN_PROGRAM_ID,\n              systemProgram: SystemProgram.programId,\n              rent: SYSVAR_RENT_PUBKEY,\n            })\n            .remainingAccounts(\n              getRemainingAccountsForKind(\n                receiptMintId,\n                receiptType === ReceiptType.Original\n                  ? TokenManagerKind.Edition\n                  : TokenManagerKind.Managed\n              )\n            )\n            .instruction();\n          transaction.add(ix);\n        }\n      }\n    }\n    txs.push({ tx: transaction });\n  }\n  return preTxs.length > 0 ? [preTxs, txs] : [txs];\n};\n\nexport const unstake = async (\n  connection: Connection,\n  wallet: Wallet,\n  params: {\n    stakePoolId: PublicKey;\n    originalMintId: PublicKey;\n    fungible?: boolean;\n    stakeEntryId?: PublicKey;\n  }\n): Promise<Transaction> => {\n  const txSeq = await unstakeAll(connection, wallet, {\n    stakePoolId: params.stakePoolId,\n    mintInfos: [\n      {\n        mintId: params.originalMintId,\n        fungible: params.fungible,\n        stakeEntryId: params.stakeEntryId,\n      },\n    ],\n  });\n  const txs = txSeq[0];\n  if (!txs) throw \"Failed to unstake\";\n  const tx = txs[0];\n  if (!tx) throw \"Failed to unstake\";\n  return tx.tx;\n};\n\n/**\n * Convenience method to unstake tokens\n * @param connection - Connection to use\n * @param wallet - Wallet to use\n * @param stakePoolId - Stake pool ID\n * @param originalMintId - Original mint ID\n * @returns\n */\nexport const unstakeAll = async (\n  connection: Connection,\n  wallet: Wallet,\n  params: {\n    stakePoolId: PublicKey;\n    mintInfos: {\n      mintId: PublicKey;\n      stakeEntryId?: PublicKey;\n      fungible?: boolean;\n    }[];\n  }\n): Promise<{ tx: Transaction; signers?: Signer[] }[][]> => {\n  /////// derive ids ///////\n  const mintInfos = params.mintInfos.map(\n    ({ mintId, fungible, stakeEntryId }) => ({\n      mintId,\n      fungible,\n      mintMetadataId: findMintMetadataId(mintId),\n      userOriginalMintTokenAccountId: getAssociatedTokenAddressSync(\n        mintId,\n        wallet.publicKey\n      ),\n      stakeEntryId:\n        stakeEntryId ??\n        findStakeEntryId(\n          wallet.publicKey,\n          params.stakePoolId,\n          mintId,\n          fungible ?? false\n        ),\n    })\n  );\n  const rewardDistributorId = findRewardDistributorId(params.stakePoolId);\n\n  /////// get accounts ///////\n  const accountData = await fetchAccountDataById(connection, [\n    rewardDistributorId,\n    params.stakePoolId,\n    ...mintInfos.map(({ mintMetadataId }) => mintMetadataId),\n    ...mintInfos.map(({ stakeEntryId }) => stakeEntryId),\n    ...mintInfos.map(({ mintId, userOriginalMintTokenAccountId }) =>\n      findTokenRecordId(mintId, userOriginalMintTokenAccountId)\n    ),\n  ]);\n\n  const stakePoolInfo = accountData[params.stakePoolId.toString()];\n  if (!stakePoolInfo?.data) throw \"Stake pool not found\";\n  const stakePoolData = decodeIdlAccount<\"stakePool\", CardinalStakePool>(\n    stakePoolInfo,\n    \"stakePool\",\n    STAKE_POOL_IDL\n  );\n  const rewardDistributorInfo = accountData[rewardDistributorId.toString()];\n  const rewardDistributorData = rewardDistributorInfo\n    ? tryDecodeIdlAccount<\"rewardDistributor\", CardinalRewardDistributor>(\n        rewardDistributorInfo,\n        \"rewardDistributor\",\n        REWARD_DISTRIBUTOR_IDL\n      )\n    : null;\n  const rewardMintId = rewardDistributorData?.parsed?.rewardMint;\n  const userRewardTokenAccountId = rewardMintId\n    ? getAssociatedTokenAddressSync(rewardMintId, wallet.publicKey, true)\n    : null;\n\n  const txs: { tx: Transaction }[] = [];\n  for (const {\n    mintId: originalMintId,\n    stakeEntryId,\n    mintMetadataId,\n    userOriginalMintTokenAccountId,\n  } of mintInfos) {\n    /////// deserialize accounts ///////\n    const metadataAccountInfo = accountData[mintMetadataId.toString()];\n    const mintMetadata = metadataAccountInfo\n      ? Metadata.deserialize(metadataAccountInfo.data)[0]\n      : null;\n    const tokenRecordInfo =\n      accountData[\n        findTokenRecordId(\n          originalMintId,\n          userOriginalMintTokenAccountId\n        ).toString()\n      ];\n    const tokenRecordData = tokenRecordInfo\n      ? TokenRecord.fromAccountInfo(tokenRecordInfo)[0]\n      : null;\n\n    /////// start transaction ///////\n    const tx = new Transaction();\n\n    /////// init user token account ///////\n\n    tx.add(\n      createAssociatedTokenAccountIdempotentInstruction(\n        wallet.publicKey,\n        userOriginalMintTokenAccountId,\n        wallet.publicKey,\n        originalMintId\n      )\n    );\n\n    if (rewardDistributorData?.parsed && userRewardTokenAccountId) {\n      /////// update total stake seconds ///////\n      const updateIx = await stakePoolProgram(connection, wallet)\n        .methods.updateTotalStakeSeconds()\n        .accountsStrict({\n          stakeEntry: stakeEntryId,\n          lastStaker: wallet.publicKey,\n        })\n        .instruction();\n      tx.add(updateIx);\n\n      /////// claim rewards ///////\n      const rewardEntryId = findRewardEntryId(\n        rewardDistributorId,\n        stakeEntryId\n      );\n      const rewardEntry = await tryGetAccount(() =>\n        getRewardEntry(connection, rewardEntryId)\n      );\n\n      if (!rewardEntry) {\n        const ix = await rewardDistributorProgram(connection, wallet)\n          .methods.initRewardEntry()\n          .accountsStrict({\n            rewardEntry: findRewardEntryId(rewardDistributorId, stakeEntryId),\n            rewardDistributor: rewardDistributorId,\n            stakeEntry: stakeEntryId,\n            payer: wallet.publicKey,\n            systemProgram: SystemProgram.programId,\n          })\n          .instruction();\n        tx.add(ix);\n      }\n      const stakeEntryInfo = accountData[stakeEntryId.toString()]!;\n      const stakeEntryData = decodeIdlAccount<\"stakeEntry\", CardinalStakePool>(\n        stakeEntryInfo,\n        \"stakeEntry\",\n        STAKE_POOL_IDL\n      );\n      const ix = await rewardDistributorProgram(connection, wallet)\n        .methods.claimRewards()\n        .accountsStrict({\n          rewardEntry: rewardEntryId,\n          rewardDistributor: rewardDistributorId,\n          stakeEntry: stakeEntryId,\n          stakePool: params.stakePoolId,\n          rewardMint: rewardDistributorData.parsed.rewardMint,\n          userRewardMintTokenAccount: userRewardTokenAccountId,\n          rewardManager: REWARD_MANAGER,\n          user: wallet.publicKey,\n          tokenProgram: TOKEN_PROGRAM_ID,\n          systemProgram: SystemProgram.programId,\n        })\n        .remainingAccounts([\n          {\n            pubkey: getAssociatedTokenAddressSync(\n              rewardDistributorData.parsed.rewardMint,\n              rewardDistributorId,\n              true\n            ),\n            isSigner: false,\n            isWritable: true,\n          },\n        ])\n        .instruction();\n      if (\n        !(\n          rewardDistributorData.parsed.maxRewardSecondsReceived &&\n          stakeEntryData.parsed.totalStakeSeconds >\n            rewardDistributorData.parsed.maxRewardSecondsReceived\n        )\n      ) {\n        tx.add(ix);\n      }\n    }\n    if (\n      mintMetadata?.tokenStandard === TokenStandard.ProgrammableNonFungible &&\n      mintMetadata.programmableConfig?.ruleSet &&\n      tokenRecordData?.delegateRole === TokenDelegateRole.Staking\n    ) {\n      /////// programmable ///////\n      tx.add(\n        ComputeBudgetProgram.setComputeUnitLimit({\n          units: 100000000,\n        })\n      );\n      const ix = await stakePoolProgram(connection, wallet)\n        .methods.unstakeProgrammable()\n        .accountsStrict({\n          stakeEntry: stakeEntryId,\n          stakePool: params.stakePoolId,\n          originalMint: originalMintId,\n          systemProgram: SystemProgram.programId,\n          user: wallet.publicKey,\n          tokenProgram: TOKEN_PROGRAM_ID,\n          tokenMetadataProgram: METADATA_PROGRAM_ID,\n          userOriginalMintTokenAccount: userOriginalMintTokenAccountId,\n          userOriginalMintTokenRecord: findTokenRecordId(\n            originalMintId,\n            userOriginalMintTokenAccountId\n          ),\n          mintMetadata: mintMetadataId,\n          mintEdition: findMintEditionId(originalMintId),\n          authorizationRules: mintMetadata.programmableConfig?.ruleSet,\n          sysvarInstructions: SYSVAR_INSTRUCTIONS_PUBKEY,\n          authorizationRulesProgram: TOKEN_AUTH_RULES_ID,\n        })\n        .instruction();\n      tx.add(ix);\n    } else {\n      /////// non-programmable ///////\n      const stakeEntryInfo = accountData[stakeEntryId.toString()];\n      if (!stakeEntryInfo) throw \"Stake entry not found\";\n      const stakeEntry = decodeIdlAccount<\"stakeEntry\", CardinalStakePool>(\n        stakeEntryInfo,\n        \"stakeEntry\",\n        STAKE_POOL_IDL\n      );\n\n      if (\n        stakeEntry.parsed.stakeMintClaimed ||\n        stakeEntry.parsed.originalMintClaimed\n      ) {\n        /////// receipts ///////\n        const receiptMint =\n          stakeEntry.parsed.stakeMint && stakeEntry.parsed.stakeMintClaimed\n            ? stakeEntry.parsed.stakeMint\n            : stakeEntry.parsed.originalMint;\n\n        const tokenManagerId = findTokenManagerAddress(receiptMint);\n\n        // todo network call in loop for token manager data\n        const tokenManagerData = await tryNull(() =>\n          tokenManager.accounts.getTokenManager(connection, tokenManagerId)\n        );\n        if (\n          tokenManagerData &&\n          shouldReturnReceipt(stakePoolData.parsed, stakeEntry.parsed)\n        ) {\n          const remainingAccounts = await withRemainingAccountsForInvalidate(\n            tx,\n            connection,\n            wallet,\n            receiptMint,\n            tokenManagerData,\n            stakeEntryId,\n            mintMetadata\n          );\n          const ix = await stakePoolProgram(connection, wallet)\n            .methods.returnReceiptMint()\n            .accountsStrict({\n              stakeEntry: stakeEntryId,\n              receiptMint: receiptMint,\n              tokenManager: tokenManagerId,\n              tokenManagerTokenAccount: getAssociatedTokenAddressSync(\n                receiptMint,\n                tokenManagerId,\n                true\n              ),\n              userReceiptMintTokenAccount: getAssociatedTokenAddressSync(\n                receiptMint,\n                wallet.publicKey,\n                true\n              ),\n              user: wallet.publicKey,\n              collector: CRANK_KEY,\n              tokenProgram: TOKEN_PROGRAM_ID,\n              tokenManagerProgram: TOKEN_MANAGER_ADDRESS,\n              rent: SYSVAR_RENT_PUBKEY,\n            })\n            .remainingAccounts(remainingAccounts)\n            .instruction();\n          tx.add(ix);\n        }\n      }\n      const stakeEntryOriginalMintTokenAccountId =\n        getAssociatedTokenAddressSync(originalMintId, stakeEntryId, true);\n      const program = stakePoolProgram(connection, wallet);\n\n      if (mintMetadata?.programmableConfig?.ruleSet) {\n        tx.add(\n          ComputeBudgetProgram.setComputeUnitLimit({\n            units: 100000000,\n          })\n        );\n        const ix = await program.methods\n          .unstakeCustodialProgrammable()\n          .accountsStrict({\n            stakePool: params.stakePoolId,\n            stakeEntry: stakeEntryId,\n            originalMint: originalMintId,\n            stakeEntryOriginalMintTokenAccount:\n              stakeEntryOriginalMintTokenAccountId,\n            user: wallet.publicKey,\n            userOriginalMintTokenAccount: userOriginalMintTokenAccountId,\n            stakeEntryOriginalMintTokenRecord: findTokenRecordId(\n              originalMintId,\n              stakeEntryOriginalMintTokenAccountId\n            ),\n            userOriginalMintTokenRecord: findTokenRecordId(\n              originalMintId,\n              userOriginalMintTokenAccountId\n            ),\n            mintMetadata: mintMetadataId,\n            mintEdition: findMintEditionId(originalMintId),\n            authorizationRules: mintMetadata.programmableConfig?.ruleSet,\n            sysvarInstructions: SYSVAR_INSTRUCTIONS_PUBKEY,\n            tokenProgram: TOKEN_PROGRAM_ID,\n            associatedTokenProgram: ASSOCIATED_TOKEN_PROGRAM_ID,\n            tokenMetadataProgram: METADATA_PROGRAM_ID,\n            authorizationRulesProgram: TOKEN_AUTH_RULES_ID,\n            systemProgram: SystemProgram.programId,\n          })\n          .instruction();\n        tx.add(ix);\n      } else {\n        const ix = await program.methods\n          .unstake()\n          .accountsStrict({\n            stakePool: params.stakePoolId,\n            stakeEntry: stakeEntryId,\n            originalMint: originalMintId,\n            stakeEntryOriginalMintTokenAccount:\n              stakeEntryOriginalMintTokenAccountId,\n            user: wallet.publicKey,\n            userOriginalMintTokenAccount: userOriginalMintTokenAccountId,\n            tokenProgram: TOKEN_PROGRAM_ID,\n          })\n          .remainingAccounts(\n            stakeEntry.parsed.stakeMint\n              ? [\n                  {\n                    pubkey: getAssociatedTokenAddressSync(\n                      stakeEntry.parsed.stakeMint,\n                      stakeEntryId,\n                      true\n                    ),\n                    isSigner: false,\n                    isWritable: false,\n                  },\n                ]\n              : []\n          )\n          .instruction();\n        tx.add(ix);\n      }\n    }\n    txs.push({ tx });\n  }\n\n  /////// preTxs ///////\n  let rewardTokenAccount: Account | null = null;\n  if (userRewardTokenAccountId && rewardMintId) {\n    rewardTokenAccount = await tryNull(\n      getAccount(connection, userRewardTokenAccountId)\n    );\n  }\n  return !rewardTokenAccount && userRewardTokenAccountId && rewardMintId\n    ? [\n        txs.slice(0, 1).map(({ tx }) => {\n          tx.instructions = [\n            createAssociatedTokenAccountIdempotentInstruction(\n              wallet.publicKey,\n              userRewardTokenAccountId,\n              wallet.publicKey,\n              rewardMintId\n            ),\n            ...tx.instructions,\n          ];\n          return { tx };\n        }),\n        txs.slice(1),\n      ]\n    : [txs];\n};\n\n/**\n * Convenience call to create a group entry\n * @param connection - Connection to use\n * @param wallet - Wallet to use\n * @param params\n * stakePoolId - Stake pool ID\n * originalMintId - Original mint ID\n * user - (Optional) User pubkey in case the person paying for the transaction and\n * stake entry owner are different\n * @returns\n */\nexport const createGroupEntry = async (\n  connection: Connection,\n  wallet: Wallet,\n  params: {\n    stakeEntryIds: PublicKey[];\n    groupCooldownSeconds?: number;\n    groupStakeSeconds?: number;\n  }\n): Promise<[Transaction, PublicKey]> => {\n  if (!params.stakeEntryIds.length) throw new Error(\"No stake entry found\");\n  const [transaction, groupEntryId] = await withInitGroupStakeEntry(\n    new Transaction(),\n    connection,\n    wallet,\n    {\n      groupCooldownSeconds: params.groupCooldownSeconds,\n      groupStakeSeconds: params.groupStakeSeconds,\n    }\n  );\n\n  await Promise.all(\n    params.stakeEntryIds.map((stakeEntryId) =>\n      withAddToGroupEntry(transaction, connection, wallet, {\n        groupEntryId,\n        stakeEntryId,\n      })\n    )\n  );\n\n  return [transaction, groupEntryId];\n};\n\n/**\n * Convenience call to create a group reward distributor\n * @param connection - Connection to use\n * @param wallet - Wallet to use\n * @param params\n *  rewardMintId - (Optional) Reward mint id\n *  authorizedPools - Authorized stake pool ids\n *  rewardAmount - (Optional) Reward amount\n *  rewardDurationSeconds - (Optional) Reward duration in seconds\n *  rewardKind - (Optional) Reward distributor kind Mint or Treasury\n *  poolKind - (Optional) Reward distributor pool validation kind NoRestriction, AllFromSinglePool or EachFromSeparatePool\n *  metadataKind - (Optional) Reward distributor metadata validation kind NoRestriction, UniqueNames or UniqueSymbols\n *  supply - (Optional) Supply\n *  baseAdder - (Optional) Base adder value that will be add to the calculated multiplier\n *  baseAdderDecimals - (Optional) Base adder decimals\n *  baseMultiplier - (Optional) Base multiplier value that will be multiplied by the calculated multiplier\n *  baseMultiplierDecimals - (Optional) Base multiplier decimals\n *  multiplierDecimals - (Optional) Multiplier decimals\n *  maxSupply - (Optional) Max supply\n *  minCooldownSeconds - (Optional) number;\n *  minStakeSeconds - (Optional) number;\n *  groupCountMultiplier - (Optional) Group Count Multiplier if provided will multiplied the total reward to this number and total groups that this user has\n *  groupCountMultiplierDecimals - (Optional) Group Count Multiplier decimals\n *  minGroupSize - (Optional) min group size\n *  maxRewardSecondsReceived - (Optional) max reward seconds received\n * @returns\n */\nexport const createGroupRewardDistributor = async (\n  connection: Connection,\n  wallet: Wallet,\n  params: {\n    rewardMintId: PublicKey;\n    authorizedPools: PublicKey[];\n    rewardAmount?: BN;\n    rewardDurationSeconds?: BN;\n    rewardKind?: GroupRewardDistributorKind;\n    poolKind?: GroupRewardDistributorPoolKind;\n    metadataKind?: GroupRewardDistributorMetadataKind;\n    supply?: BN;\n    baseAdder?: BN;\n    baseAdderDecimals?: number;\n    baseMultiplier?: BN;\n    baseMultiplierDecimals?: number;\n    multiplierDecimals?: number;\n    maxSupply?: BN;\n    minCooldownSeconds?: number;\n    minStakeSeconds?: number;\n    groupCountMultiplier?: BN;\n    groupCountMultiplierDecimals?: number;\n    minGroupSize?: number;\n    maxRewardSecondsReceived?: BN;\n  }\n): Promise<[Transaction, PublicKey]> =>\n  withInitGroupRewardDistributor(new Transaction(), connection, wallet, params);\n\n/**\n * Convenience call to update a group reward distributor\n * @param connection - Connection to use\n * @param wallet - Wallet to use\n * @param params\n * groupRewardDistributorId - Group reward distributor id\n * authorizedPools - Authorized stake pool ids\n * rewardAmount - (Optional) Reward amount\n * rewardDurationSeconds - (Optional) Reward duration in seconds\n * poolKind - (Optional) Reward distributor pool validation kind NoRestriction, AllFromSinglePool or EachFromSeparatePool\n * metadataKind - (Optional) Reward distributor metadata validation kind NoRestriction, UniqueNames or UniqueSymbols\n * baseAdder - (Optional) Base adder value that will be add to the calculated multiplier\n * baseAdderDecimals - (Optional) Base adder decimals\n * baseMultiplier - (Optional) Base multiplier value that will be multiplied by the calculated multiplier\n * baseMultiplierDecimals - (Optional) Base multiplier decimals\n * multiplierDecimals - (Optional) Multiplier decimals\n * maxSupply - (Optional) Max supply\n * minCooldownSeconds - (Optional) number;\n * minStakeSeconds - (Optional) number;\n * groupCountMultiplier - (Optional) Group Count Multiplier if provided will multiplied the total reward to this number and total groups that this user has\n * groupCountMultiplierDecimals - (Optional) Group Count Multiplier decimals\n * minGroupSize - (Optional) min group size\n * maxRewardSecondsReceived - (Optional) max reward seconds received\n * @returns\n */\nexport const updateGroupRewardDistributor = async (\n  connection: Connection,\n  wallet: Wallet,\n  params: {\n    groupRewardDistributorId: PublicKey;\n    authorizedPools: PublicKey[];\n    rewardAmount?: BN;\n    rewardDurationSeconds?: BN;\n    poolKind?: GroupRewardDistributorPoolKind;\n    metadataKind?: GroupRewardDistributorMetadataKind;\n    baseAdder?: BN;\n    baseAdderDecimals?: number;\n    baseMultiplier?: BN;\n    baseMultiplierDecimals?: number;\n    multiplierDecimals?: number;\n    maxSupply?: BN;\n    minCooldownSeconds?: number;\n    minStakeSeconds?: number;\n    groupCountMultiplier?: BN;\n    groupCountMultiplierDecimals?: number;\n    minGroupSize?: number;\n    maxRewardSecondsReceived?: BN;\n  }\n): Promise<Transaction> =>\n  withUpdateGroupRewardDistributor(\n    new Transaction(),\n    connection,\n    wallet,\n    params\n  );\n\n/**\n * Convenience method to claim rewards\n * @param connection - Connection to use\n * @param wallet - Wallet to use\n * @param params\n * groupRewardDistributorId - Group reward distributor ID\n * groupEntryId - Group entry ID\n * stakeEntryIds - Stake entry IDs\n * @returns\n */\nexport const claimGroupRewards = async (\n  connection: Connection,\n  wallet: Wallet,\n  params: {\n    groupRewardDistributorId: PublicKey;\n    groupEntryId: PublicKey;\n    stakeEntryIds: PublicKey[];\n  }\n): Promise<[Transaction]> => {\n  const transaction = new Transaction();\n\n  const groupRewardEntryId = findGroupRewardEntryId(\n    params.groupRewardDistributorId,\n    params.groupEntryId\n  );\n\n  const groupRewardEntry = await tryGetAccount(() =>\n    getGroupRewardEntry(connection, groupRewardEntryId)\n  );\n  if (!groupRewardEntry) {\n    const stakeEntriesData = await getStakeEntries(\n      connection,\n      params.stakeEntryIds\n    );\n\n    const stakeEntries = await Promise.all(\n      stakeEntriesData.map((stakeEntry) => {\n        const rewardDistributorId = findRewardDistributorId(\n          stakeEntry.parsed.pool\n        );\n        return {\n          stakeEntryId: stakeEntry.pubkey,\n          originalMint: stakeEntry.parsed.originalMint,\n          rewardDistributorId,\n        };\n      })\n    );\n\n    await withInitGroupRewardEntry(transaction, connection, wallet, {\n      groupRewardDistributorId: params.groupRewardDistributorId,\n      groupEntryId: params.groupEntryId,\n      stakeEntries,\n    });\n  }\n\n  await withClaimGroupRewards(transaction, connection, wallet, {\n    groupRewardDistributorId: params.groupRewardDistributorId,\n    groupEntryId: params.groupEntryId,\n  });\n\n  return [transaction];\n};\n\n/**\n * Convenience method to close group stake entry\n * @param connection - Connection to use\n * @param wallet - Wallet to use\n * @param params\n * groupRewardDistributorId - Group reward distributor ID\n * groupEntryId - Group entry ID\n * stakeEntryIds - Stake entry IDs\n * @returns\n */\nexport const closeGroupEntry = async (\n  connection: Connection,\n  wallet: Wallet,\n  params: {\n    groupRewardDistributorId: PublicKey;\n    groupEntryId: PublicKey;\n    stakeEntryIds: PublicKey[];\n  }\n): Promise<[Transaction]> => {\n  const [transaction] = await claimGroupRewards(connection, wallet, params);\n\n  await withCloseGroupRewardEntry(transaction, connection, wallet, {\n    groupEntryId: params.groupEntryId,\n    groupRewardDistributorId: params.groupRewardDistributorId,\n  });\n\n  await Promise.all(\n    params.stakeEntryIds.map((stakeEntryId) =>\n      withRemoveFromGroupEntry(transaction, connection, wallet, {\n        groupEntryId: params.groupEntryId,\n        stakeEntryId,\n      })\n    )\n  );\n  return [transaction];\n};\n\n/**\n * Convenience method to init ungrouping\n * @param connection - Connection to use\n * @param wallet - Wallet to use\n * @param params\n * groupRewardDistributorId - Group reward distributor ID\n * groupEntryId - Group entry ID\n * stakeEntryIds - Stake entry IDs\n * @returns\n */\nexport const initUngrouping = async (\n  connection: Connection,\n  wallet: Wallet,\n  params: {\n    groupEntryId: PublicKey;\n  }\n): Promise<[Transaction]> => {\n  const transaction = new Transaction();\n\n  await withInitUngrouping(transaction, connection, wallet, {\n    groupEntryId: params.groupEntryId,\n  });\n\n  return [transaction];\n};\n"]}