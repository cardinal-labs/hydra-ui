"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getInvalidCertificates = exports.getOutstandingCertificates = exports.getCertificates = exports.getCertificate = exports.getCertificatesForMints = void 0;
const anchor = __importStar(require("@project-serum/anchor"));
const utils_1 = require("./utils");
/**
 * Gets certificates for a a list of mintIds
 * @param connection
 * @param mints
 * @returns List of certificates for the given mintIds
 */
async function getCertificatesForMints(connection, mints) {
    const certificatesIds = await Promise.all(mints.map((mint) => (0, utils_1.certificateIdForMint)(mint)[0]));
    const provider = new anchor.Provider(connection, null, {});
    const program = new anchor.Program(utils_1.CERTIFICATE_IDL, utils_1.CERTIFICATE_PROGRAM_ID, provider);
    const result = await program.account.certificate.fetchMultiple(certificatesIds);
    return result.map((parsed, i) => ({
        parsed,
        pubkey: certificatesIds[i],
    }));
}
exports.getCertificatesForMints = getCertificatesForMints;
async function getCertificate(connection, certificateId) {
    const provider = new anchor.Provider(connection, null, {});
    const program = new anchor.Program(utils_1.CERTIFICATE_IDL, utils_1.CERTIFICATE_PROGRAM_ID, provider);
    const parsed = await program.account.certificate.fetch(certificateId);
    return {
        parsed,
        pubkey: certificateId,
    };
}
exports.getCertificate = getCertificate;
/**
 * Get a list of certificates given a list of certificate public keys
 * @param connection
 * @param certificateIds
 * @returns List of certificates
 */
async function getCertificates(connection, certificateIds) {
    const provider = new anchor.Provider(connection, null, {});
    const program = new anchor.Program(utils_1.CERTIFICATE_IDL, utils_1.CERTIFICATE_PROGRAM_ID, provider);
    let certificates = [];
    try {
        certificates = await program.account.certificate.fetchMultiple(certificateIds);
    }
    catch (e) {
        console.log(e);
    }
    return certificates.map((c, i) => ({
        parsed: c,
        pubkey: certificateIds[i],
    }));
}
exports.getCertificates = getCertificates;
/**
 * Get all outstanding certificates serialized and sorted pertaining to this user
 * TODO this is inefficient and should be replaced with a call to an indexed set of IDs but it's okay for now
 * @param connection web3 connection
 * @param user use public key
 * @returns List of outstanding certificates pertaining to this user
 */
async function getOutstandingCertificates(connection, user) {
    const coder = new anchor.Coder(utils_1.CERTIFICATE_IDL);
    const programAccounts = await connection.getProgramAccounts(utils_1.CERTIFICATE_PROGRAM_ID);
    const outstandingCertifices = [];
    programAccounts.forEach((account) => {
        try {
            console.log(account, coder.accounts);
            // todo figure out typescript types for decoding
            const certificate = coder.accounts.decode("certificate", account.account.data);
            if ((user && user.toBase58() === certificate.issuer.toBase58()) ||
                (user && user.toBase58() === certificate.revokeAuthority.toBase58()) ||
                certificate.state === utils_1.CertificateState.Issued) {
                outstandingCertifices.push({
                    ...account,
                    parsed: certificate,
                });
            }
        }
        catch (e) {
            console.log(`Failed to decode certificate ${e}`);
        }
    });
    const sortedOutstandingCertifices = outstandingCertifices.sort((a, b) => a.pubkey.toBase58().localeCompare(b.pubkey.toBase58()));
    return sortedOutstandingCertifices;
}
exports.getOutstandingCertificates = getOutstandingCertificates;
/**
 * Get all invalid certificates
 * TODO this is inefficient and should be replaced with a call to an indexed set of IDs but it's okay for now
 * @param connection web3 connection
 * @returns List of invalid certificates
 */
async function getInvalidCertificates(connection) {
    const coder = new anchor.Coder(utils_1.CERTIFICATE_IDL);
    const programAccounts = await connection.getProgramAccounts(utils_1.CERTIFICATE_PROGRAM_ID);
    const invalidCertificates = [];
    programAccounts.forEach((account) => {
        try {
            // todo figure out typescript types for decoding
            const certificate = coder.accounts.decode("certificate", account.account.data);
            if ((Math.floor(Date.now() / 1000) > certificate.expiration ||
                certificate.usages >= certificate.maxUsages) &&
                certificate.state !== utils_1.CertificateState.Invalidated) {
                invalidCertificates.push({
                    ...account,
                    parsed: certificate,
                });
            }
        }
        catch (e) {
            console.log(`Failed to decode certificate ${e}`);
        }
    });
    return invalidCertificates;
}
exports.getInvalidCertificates = getInvalidCertificates;
//# sourceMappingURL=accounts.js.map